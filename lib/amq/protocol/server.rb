# encoding: binary

# THIS IS AN AUTOGENERATED FILE, DO NOT MODIFY
# IT DIRECTLY ! FOR CHANGES, PLEASE UPDATE CODEGEN.PY
# IN THE ROOT DIRECTORY OF THE AMQ-PROTOCOL REPOSITORY.

require "amq/protocol/table.rb"
require "amq/protocol/frame.rb"
require "amq/protocol/hacks.rb"

module AMQ
  module Protocol
    PROTOCOL_VERSION = "0.9.1".freeze
    PREAMBLE         = "AMQP\x00\x00\x09\x01".freeze
    DEFAULT_PORT     = 5672.freeze

    # caching
    EMPTY_STRING = "".freeze
    PACK_CACHE = Hash.new { |hash, key| hash[key] = key.to_s }
    # At the beginning, the PACK_CACHE is empty. When we query the cache, we"ll get back the key as a string.
    # So instead of creating a lot of strings in each pack/unpack call, we just query the cache and get back what we need.
    # PACK_CACHE[:n2Q] # => "n2Q" # via the PACK_CACHE.default_proc
    # PACK_CACHE[:n2Q] # => "n2Q" # standard hash query

    # @version 0.0.1
    # @return [Array] Collection of subclasses of AMQ::Protocol::Class.
    def self.classes
      Protocol::Class.classes
    end

    # @version 0.0.1
    # @return [Array] Collection of subclasses of AMQ::Protocol::Method.
    def self.methods
      Protocol::Method.methods
    end

    class Error < StandardError
      DEFAULT_MESSAGE = "AMQP error".freeze

      def self.inherited(subclass)
        @_subclasses ||= []
        @_subclasses << subclass
      end # self.inherited(subclazz)

      def self.subclasses_with_values
        @_subclasses.select{ |k| defined?(k::VALUE) }
      end # self.subclasses_with_values

      def self.[](code) # TODO: rewrite more effectively
        if result = subclasses_with_values.detect { |klass| klass::VALUE == code }
          result
        else
          raise "No such exception class for code #{code}" unless result
        end # if
      end # self.[]

      def initialize(message = self.class::DEFAULT_MESSAGE)
        super(message)
      end
    end

    class FrameTypeError < Protocol::Error
      def initialize(types)
        super("Must be one of #{types.inspect}")
      end
    end

    class EmptyResponseError < Protocol::Error
      DEFAULT_MESSAGE = "Empty response received from the server."

      def initialize(message = self.class::DEFAULT_MESSAGE)
        super(message)
      end
    end

    class BadResponseError < Protocol::Error
      def initialize(argument, expected, actual)
        super("Argument #{argument} has to be #{expected.inspect}, was #{data.inspect}")
      end
    end

    class SoftError < Protocol::Error
      def self.inherited(subclass)
        Error.inherited(subclass)
      end # self.inherited(subclass)
    end

    class HardError < Protocol::Error
      def self.inherited(subclass)
        Error.inherited(subclass)
      end # self.inherited(subclass)
    end

    class ContentTooLarge < SoftError
      VALUE = 311
    end

    class NoRoute < SoftError
      VALUE = 312
    end

    class NoConsumers < SoftError
      VALUE = 313
    end

    class AccessRefused < SoftError
      VALUE = 403
    end

    class NotFound < SoftError
      VALUE = 404
    end

    class ResourceLocked < SoftError
      VALUE = 405
    end

    class PreconditionFailed < SoftError
      VALUE = 406
    end

    class ConnectionForced < HardError
      VALUE = 320
    end

    class InvalidPath < HardError
      VALUE = 402
    end

    class FrameError < HardError
      VALUE = 501
    end

    class SyntaxError < HardError
      VALUE = 502
    end

    class CommandInvalid < HardError
      VALUE = 503
    end

    class ChannelError < HardError
      VALUE = 504
    end

    class UnexpectedFrame < HardError
      VALUE = 505
    end

    class ResourceError < HardError
      VALUE = 506
    end

    class NotAllowed < HardError
      VALUE = 530
    end

    class NotImplemented < HardError
      VALUE = 540
    end

    class InternalError < HardError
      VALUE = 541
    end

    # We don"t instantiate the following classes,
    # as we don"t actually need any per-instance state.
    # Also, this is pretty low-level functionality,
    # hence it should have a reasonable performance.
    # As everyone knows, garbage collector in MRI performs
    # really badly, which is another good reason for
    # not creating any objects, but only use class as
    # a struct. Creating classes is quite expensive though,
    # but here the inheritance comes handy and mainly
    # as we can"t simply make a reference to a function,
    # we can"t use a hash or an object. I"ve been also
    # considering to have just a bunch of methods, but
    # here"s the problem, that after we"d require this file,
    # all these methods would become global which would
    # be a bad, bad thing to do.
    class Class
      @classes = Array.new

      def self.method_id
        @method_id
      end

      def self.name
        @name
      end

      def self.inherited(base)
        if self == Protocol::Class
          @classes << base
        end
      end

      def self.classes
        @classes
      end
    end

    class Method
      @methods = Array.new
      def self.method_id
        @method_id
      end

      def self.name
        @name
      end

      def self.index
        @index
      end

      def self.inherited(base)
        if self == Protocol::Method
          @methods << base
        end
      end

      def self.methods
        @methods
      end

      def self.split_headers(user_headers)
        properties, headers = {}, {}
        user_headers.each do |key, value|
					# key MUST be a symbol since symbols are not garbage-collected
          if Basic::PROPERTIES.include?(key)
            properties[key] = value
          else
            headers[key] = value
          end
        end

        return [properties, headers]
      end

      def self.encode_body(body, channel, frame_size)
        # Spec is broken: Our errata says that it does define
        # something, but it just doesn"t relate do method and
        # properties frames. Which makes it, well, suboptimal.
        # https://dev.rabbitmq.com/wiki/Amqp091Errata#section_11
        limit = frame_size - 7 - 1

        Array.new.tap do |array|
          while body
            payload, body = body[0, limit + 1], body[limit, body.length - limit]
            # array << [0x03, payload]
            array << BodyFrame.new(payload, channel)
          end
        end
      end

      # We can return different:
      # - instantiate given subclass of Method
      # - create an OpenStruct object
      # - create a hash
      # - yield params into the block rather than just return
      # @api plugin
      def self.instantiate(*args, &block)
        self.new(*args, &block)
        # or OpenStruct.new(args.first)
        # or args.first
        # or block.call(*args)
      end
    end

    class Connection < Protocol::Class
      @name = "connection"
      @method_id = 10

      class Start < Protocol::Method
        @name = "connection.start"
        @method_id = 10
        @index = 0x000A000A # 10, 10, 655370

        def self.has_content?
          false
        end

        # @return
        # ["version_major = false", "version_minor = 9", "server properties = nil", "mechanisms = "PLAIN"", "locales = "en_US""]
        def self.encode(version_major, version_minor, server_properties, mechanisms, locales)
          channel = 0
          pieces = []
          pieces << [10, 10].pack(PACK_CACHE[:n2])
          pieces << [version_major].pack(PACK_CACHE[:c])
          pieces << [version_minor].pack(PACK_CACHE[:c])
          pieces << AMQ::Protocol::Table.encode(server_properties)
          pieces << [mechanisms.bytesize].pack(PACK_CACHE[:N])
          pieces << mechanisms
          pieces << [locales.bytesize].pack(PACK_CACHE[:N])
          pieces << locales
          buffer = pieces.join(EMPTY_STRING)
          MethodFrame.new(buffer, channel)
        end
      end

      class StartOk < Protocol::Method
        @name = "connection.start-ok"
        @method_id = 11
        @index = 0x000A000B # 10, 11, 655371

        # @return
        def self.decode(data)
          offset = 0
          table_length = Table.length(data[offset, 5])
          client_properties = Table.decode(data[offset, table_length - offset + 1])
          length = data[offset, 2].unpack(PACK_CACHE[:c])[0]
          offset += 1
          mechanism = data[offset, length]
          offset += length
          length = data[offset, 5].unpack(PACK_CACHE[:N]).first
          offset += 4
          response = data[offset, length]
          offset += length
          length = data[offset, 2].unpack(PACK_CACHE[:c])[0]
          offset += 1
          locale = data[offset, length]
          offset += length
          self.new(client_properties, mechanism, response, locale)
        end

        attr_reader :client_properties, :mechanism, :response, :locale
        def initialize(client_properties, mechanism, response, locale)
          @client_properties = client_properties
          @mechanism = mechanism
          @response = response
          @locale = locale
        end

        def self.has_content?
          false
        end
      end

      class Secure < Protocol::Method
        @name = "connection.secure"
        @method_id = 20
        @index = 0x000A0014 # 10, 20, 655380

        def self.has_content?
          false
        end

        # @return
        # ["challenge = nil"]
        def self.encode(challenge)
          channel = 0
          pieces = []
          pieces << [10, 20].pack(PACK_CACHE[:n2])
          pieces << [challenge.bytesize].pack(PACK_CACHE[:N])
          pieces << challenge
          buffer = pieces.join(EMPTY_STRING)
          MethodFrame.new(buffer, channel)
        end
      end

      class SecureOk < Protocol::Method
        @name = "connection.secure-ok"
        @method_id = 21
        @index = 0x000A0015 # 10, 21, 655381

        # @return
        def self.decode(data)
          offset = 0
          length = data[offset, 5].unpack(PACK_CACHE[:N]).first
          offset += 4
          response = data[offset, length]
          offset += length
          self.new(response)
        end

        attr_reader :response
        def initialize(response)
          @response = response
        end

        def self.has_content?
          false
        end
      end

      class Tune < Protocol::Method
        @name = "connection.tune"
        @method_id = 30
        @index = 0x000A001E # 10, 30, 655390

        def self.has_content?
          false
        end

        # @return
        # ["channel_max = false", "frame_max = false", "heartbeat = false"]
        def self.encode(channel_max, frame_max, heartbeat)
          channel = 0
          pieces = []
          pieces << [10, 30].pack(PACK_CACHE[:n2])
          pieces << [channel_max].pack(PACK_CACHE[:n])
          pieces << [frame_max].pack(PACK_CACHE[:N])
          pieces << [heartbeat].pack(PACK_CACHE[:n])
          buffer = pieces.join(EMPTY_STRING)
          MethodFrame.new(buffer, channel)
        end
      end

      class TuneOk < Protocol::Method
        @name = "connection.tune-ok"
        @method_id = 31
        @index = 0x000A001F # 10, 31, 655391

        # @return
        def self.decode(data)
          offset = 0
          channel_max = data[offset, 3].unpack(PACK_CACHE[:n]).first
          offset += 2
          frame_max = data[offset, 5].unpack(PACK_CACHE[:N]).first
          offset += 4
          heartbeat = data[offset, 3].unpack(PACK_CACHE[:n]).first
          offset += 2
          self.new(channel_max, frame_max, heartbeat)
        end

        attr_reader :channel_max, :frame_max, :heartbeat
        def initialize(channel_max, frame_max, heartbeat)
          @channel_max = channel_max
          @frame_max = frame_max
          @heartbeat = heartbeat
        end

        def self.has_content?
          false
        end
      end

      class Open < Protocol::Method
        @name = "connection.open"
        @method_id = 40
        @index = 0x000A0028 # 10, 40, 655400

        # @return
        def self.decode(data)
          offset = 0
          length = data[offset, 2].unpack(PACK_CACHE[:c])[0]
          offset += 1
          virtual_host = data[offset, length]
          offset += length
          length = data[offset, 2].unpack(PACK_CACHE[:c])[0]
          offset += 1
          capabilities = data[offset, length]
          offset += length
          bit_buffer = data[offset, 2].unpack(PACK_CACHE[:c]).first
          offset += 1
          insist = (bit_buffer & (1 << 0)) != 0
          self.new(virtual_host, capabilities, insist)
        end

        attr_reader :virtual_host, :capabilities, :insist
        def initialize(virtual_host, capabilities, insist)
          @virtual_host = virtual_host
          @capabilities = capabilities
          @insist = insist
        end

        def self.has_content?
          false
        end
      end

      class OpenOk < Protocol::Method
        @name = "connection.open-ok"
        @method_id = 41
        @index = 0x000A0029 # 10, 41, 655401

        def self.has_content?
          false
        end

        # @return
        # ["known_hosts = EMPTY_STRING"]
        def self.encode(known_hosts)
          channel = 0
          pieces = []
          pieces << [10, 41].pack(PACK_CACHE[:n2])
          pieces << known_hosts.bytesize.chr
          pieces << known_hosts
          buffer = pieces.join(EMPTY_STRING)
          MethodFrame.new(buffer, channel)
        end
      end

      class Close < Protocol::Method
        @name = "connection.close"
        @method_id = 50
        @index = 0x000A0032 # 10, 50, 655410

        # @return
        def self.decode(data)
          offset = 0
          reply_code = data[offset, 3].unpack(PACK_CACHE[:n]).first
          offset += 2
          length = data[offset, 2].unpack(PACK_CACHE[:c])[0]
          offset += 1
          reply_text = data[offset, length]
          offset += length
          class_id = data[offset, 3].unpack(PACK_CACHE[:n]).first
          offset += 2
          method_id = data[offset, 3].unpack(PACK_CACHE[:n]).first
          offset += 2
          if reply_code.eql?(200)
            self.new(reply_code, reply_text, class_id, method_id)
          else
            raise Error[reply_code].new(reply_text)
          end
        end

        attr_reader :reply_code, :reply_text, :class_id, :method_id
        def initialize(reply_code, reply_text, class_id, method_id)
          @reply_code = reply_code
          @reply_text = reply_text
          @class_id = class_id
          @method_id = method_id
        end

        def self.has_content?
          false
        end

        # @return
        # ["reply_code = nil", "reply_text = EMPTY_STRING", "class_id = nil", "method_id = nil"]
        def self.encode(reply_code, reply_text, class_id, method_id)
          channel = 0
          pieces = []
          pieces << [10, 50].pack(PACK_CACHE[:n2])
          pieces << [reply_code].pack(PACK_CACHE[:n])
          pieces << reply_text.bytesize.chr
          pieces << reply_text
          pieces << [class_id].pack(PACK_CACHE[:n])
          pieces << [method_id].pack(PACK_CACHE[:n])
          buffer = pieces.join(EMPTY_STRING)
          MethodFrame.new(buffer, channel)
        end
      end

      class CloseOk < Protocol::Method
        @name = "connection.close-ok"
        @method_id = 51
        @index = 0x000A0033 # 10, 51, 655411

        # @return
        def self.decode(data)
          offset = 0
          self.new()
        end

        def initialize()
        end

        def self.has_content?
          false
        end

        # @return
        # []
        def self.encode()
          channel = 0
          pieces = []
          pieces << [10, 51].pack(PACK_CACHE[:n2])
          buffer = pieces.join(EMPTY_STRING)
          MethodFrame.new(buffer, channel)
        end
      end
    end

    class Channel < Protocol::Class
      @name = "channel"
      @method_id = 20

      class Open < Protocol::Method
        @name = "channel.open"
        @method_id = 10
        @index = 0x0014000A # 20, 10, 1310730

        # @return
        def self.decode(data)
          offset = 0
          length = data[offset, 2].unpack(PACK_CACHE[:c])[0]
          offset += 1
          out_of_band = data[offset, length]
          offset += length
          self.new(out_of_band)
        end

        attr_reader :out_of_band
        def initialize(out_of_band)
          @out_of_band = out_of_band
        end

        def self.has_content?
          false
        end
      end

      class OpenOk < Protocol::Method
        @name = "channel.open-ok"
        @method_id = 11
        @index = 0x0014000B # 20, 11, 1310731

        def self.has_content?
          false
        end

        # @return
        # ["channel_id = EMPTY_STRING"]
        def self.encode(channel, channel_id)
          pieces = []
          pieces << [20, 11].pack(PACK_CACHE[:n2])
          pieces << [channel_id.bytesize].pack(PACK_CACHE[:N])
          pieces << channel_id
          buffer = pieces.join(EMPTY_STRING)
          MethodFrame.new(buffer, channel)
        end
      end

      class Flow < Protocol::Method
        @name = "channel.flow"
        @method_id = 20
        @index = 0x00140014 # 20, 20, 1310740

        # @return
        def self.decode(data)
          offset = 0
          bit_buffer = data[offset, 2].unpack(PACK_CACHE[:c]).first
          offset += 1
          active = (bit_buffer & (1 << 0)) != 0
          self.new(active)
        end

        attr_reader :active
        def initialize(active)
          @active = active
        end

        def self.has_content?
          false
        end

        # @return
        # ["active = nil"]
        def self.encode(channel, active)
          pieces = []
          pieces << [20, 20].pack(PACK_CACHE[:n2])
          bit_buffer = 0
          bit_buffer = bit_buffer | (1 << 0) if active
          pieces << [bit_buffer].pack(PACK_CACHE[:c])
          buffer = pieces.join(EMPTY_STRING)
          MethodFrame.new(buffer, channel)
        end
      end

      class FlowOk < Protocol::Method
        @name = "channel.flow-ok"
        @method_id = 21
        @index = 0x00140015 # 20, 21, 1310741

        # @return
        def self.decode(data)
          offset = 0
          bit_buffer = data[offset, 2].unpack(PACK_CACHE[:c]).first
          offset += 1
          active = (bit_buffer & (1 << 0)) != 0
          self.new(active)
        end

        attr_reader :active
        def initialize(active)
          @active = active
        end

        def self.has_content?
          false
        end

        # @return
        # ["active = nil"]
        def self.encode(channel, active)
          pieces = []
          pieces << [20, 21].pack(PACK_CACHE[:n2])
          bit_buffer = 0
          bit_buffer = bit_buffer | (1 << 0) if active
          pieces << [bit_buffer].pack(PACK_CACHE[:c])
          buffer = pieces.join(EMPTY_STRING)
          MethodFrame.new(buffer, channel)
        end
      end

      class Close < Protocol::Method
        @name = "channel.close"
        @method_id = 40
        @index = 0x00140028 # 20, 40, 1310760

        # @return
        def self.decode(data)
          offset = 0
          reply_code = data[offset, 3].unpack(PACK_CACHE[:n]).first
          offset += 2
          length = data[offset, 2].unpack(PACK_CACHE[:c])[0]
          offset += 1
          reply_text = data[offset, length]
          offset += length
          class_id = data[offset, 3].unpack(PACK_CACHE[:n]).first
          offset += 2
          method_id = data[offset, 3].unpack(PACK_CACHE[:n]).first
          offset += 2
          if reply_code.eql?(200)
            self.new(reply_code, reply_text, class_id, method_id)
          else
            raise Error[reply_code].new(reply_text)
          end
        end

        attr_reader :reply_code, :reply_text, :class_id, :method_id
        def initialize(reply_code, reply_text, class_id, method_id)
          @reply_code = reply_code
          @reply_text = reply_text
          @class_id = class_id
          @method_id = method_id
        end

        def self.has_content?
          false
        end

        # @return
        # ["reply_code = nil", "reply_text = EMPTY_STRING", "class_id = nil", "method_id = nil"]
        def self.encode(channel, reply_code, reply_text, class_id, method_id)
          pieces = []
          pieces << [20, 40].pack(PACK_CACHE[:n2])
          pieces << [reply_code].pack(PACK_CACHE[:n])
          pieces << reply_text.bytesize.chr
          pieces << reply_text
          pieces << [class_id].pack(PACK_CACHE[:n])
          pieces << [method_id].pack(PACK_CACHE[:n])
          buffer = pieces.join(EMPTY_STRING)
          MethodFrame.new(buffer, channel)
        end
      end

      class CloseOk < Protocol::Method
        @name = "channel.close-ok"
        @method_id = 41
        @index = 0x00140029 # 20, 41, 1310761

        # @return
        def self.decode(data)
          offset = 0
          self.new()
        end

        def initialize()
        end

        def self.has_content?
          false
        end

        # @return
        # []
        def self.encode(channel)
          pieces = []
          pieces << [20, 41].pack(PACK_CACHE[:n2])
          buffer = pieces.join(EMPTY_STRING)
          MethodFrame.new(buffer, channel)
        end
      end
    end

    class Exchange < Protocol::Class
      @name = "exchange"
      @method_id = 40

      class Declare < Protocol::Method
        @name = "exchange.declare"
        @method_id = 10
        @index = 0x0028000A # 40, 10, 2621450

        # @return
        def self.decode(data)
          offset = 0
          ticket = data[offset, 3].unpack(PACK_CACHE[:n]).first
          offset += 2
          length = data[offset, 2].unpack(PACK_CACHE[:c])[0]
          offset += 1
          exchange = data[offset, length]
          offset += length
          length = data[offset, 2].unpack(PACK_CACHE[:c])[0]
          offset += 1
          type = data[offset, length]
          offset += length
          bit_buffer = data[offset, 2].unpack(PACK_CACHE[:c]).first
          offset += 1
          passive = (bit_buffer & (1 << 0)) != 0
          table_length = Table.length(data[offset, 5])
          arguments = Table.decode(data[offset, table_length - offset + 1])
          self.new(ticket, exchange, type, passive, durable, auto_delete, internal, nowait, arguments)
        end

        attr_reader :ticket, :exchange, :type, :passive, :durable, :auto_delete, :internal, :nowait, :arguments
        def initialize(ticket, exchange, type, passive, durable, auto_delete, internal, nowait, arguments)
          @ticket = ticket
          @exchange = exchange
          @type = type
          @passive = passive
          @durable = durable
          @auto_delete = auto_delete
          @internal = internal
          @nowait = nowait
          @arguments = arguments
        end

        def self.has_content?
          false
        end
      end

      class DeclareOk < Protocol::Method
        @name = "exchange.declare-ok"
        @method_id = 11
        @index = 0x0028000B # 40, 11, 2621451

        def self.has_content?
          false
        end

        # @return
        # []
        def self.encode(channel)
          pieces = []
          pieces << [40, 11].pack(PACK_CACHE[:n2])
          buffer = pieces.join(EMPTY_STRING)
          MethodFrame.new(buffer, channel)
        end
      end

      class Delete < Protocol::Method
        @name = "exchange.delete"
        @method_id = 20
        @index = 0x00280014 # 40, 20, 2621460

        # @return
        def self.decode(data)
          offset = 0
          ticket = data[offset, 3].unpack(PACK_CACHE[:n]).first
          offset += 2
          length = data[offset, 2].unpack(PACK_CACHE[:c])[0]
          offset += 1
          exchange = data[offset, length]
          offset += length
          bit_buffer = data[offset, 2].unpack(PACK_CACHE[:c]).first
          offset += 1
          if_unused = (bit_buffer & (1 << 0)) != 0
          self.new(ticket, exchange, if_unused, nowait)
        end

        attr_reader :ticket, :exchange, :if_unused, :nowait
        def initialize(ticket, exchange, if_unused, nowait)
          @ticket = ticket
          @exchange = exchange
          @if_unused = if_unused
          @nowait = nowait
        end

        def self.has_content?
          false
        end
      end

      class DeleteOk < Protocol::Method
        @name = "exchange.delete-ok"
        @method_id = 21
        @index = 0x00280015 # 40, 21, 2621461

        def self.has_content?
          false
        end

        # @return
        # []
        def self.encode(channel)
          pieces = []
          pieces << [40, 21].pack(PACK_CACHE[:n2])
          buffer = pieces.join(EMPTY_STRING)
          MethodFrame.new(buffer, channel)
        end
      end

      class Bind < Protocol::Method
        @name = "exchange.bind"
        @method_id = 30
        @index = 0x0028001E # 40, 30, 2621470

        # @return
        def self.decode(data)
          offset = 0
          ticket = data[offset, 3].unpack(PACK_CACHE[:n]).first
          offset += 2
          length = data[offset, 2].unpack(PACK_CACHE[:c])[0]
          offset += 1
          destination = data[offset, length]
          offset += length
          length = data[offset, 2].unpack(PACK_CACHE[:c])[0]
          offset += 1
          source = data[offset, length]
          offset += length
          length = data[offset, 2].unpack(PACK_CACHE[:c])[0]
          offset += 1
          routing_key = data[offset, length]
          offset += length
          bit_buffer = data[offset, 2].unpack(PACK_CACHE[:c]).first
          offset += 1
          nowait = (bit_buffer & (1 << 0)) != 0
          table_length = Table.length(data[offset, 5])
          arguments = Table.decode(data[offset, table_length - offset + 1])
          self.new(ticket, destination, source, routing_key, nowait, arguments)
        end

        attr_reader :ticket, :destination, :source, :routing_key, :nowait, :arguments
        def initialize(ticket, destination, source, routing_key, nowait, arguments)
          @ticket = ticket
          @destination = destination
          @source = source
          @routing_key = routing_key
          @nowait = nowait
          @arguments = arguments
        end

        def self.has_content?
          false
        end
      end

      class BindOk < Protocol::Method
        @name = "exchange.bind-ok"
        @method_id = 31
        @index = 0x0028001F # 40, 31, 2621471

        def self.has_content?
          false
        end

        # @return
        # []
        def self.encode(channel)
          pieces = []
          pieces << [40, 31].pack(PACK_CACHE[:n2])
          buffer = pieces.join(EMPTY_STRING)
          MethodFrame.new(buffer, channel)
        end
      end

      class Unbind < Protocol::Method
        @name = "exchange.unbind"
        @method_id = 40
        @index = 0x00280028 # 40, 40, 2621480

        # @return
        def self.decode(data)
          offset = 0
          ticket = data[offset, 3].unpack(PACK_CACHE[:n]).first
          offset += 2
          length = data[offset, 2].unpack(PACK_CACHE[:c])[0]
          offset += 1
          destination = data[offset, length]
          offset += length
          length = data[offset, 2].unpack(PACK_CACHE[:c])[0]
          offset += 1
          source = data[offset, length]
          offset += length
          length = data[offset, 2].unpack(PACK_CACHE[:c])[0]
          offset += 1
          routing_key = data[offset, length]
          offset += length
          bit_buffer = data[offset, 2].unpack(PACK_CACHE[:c]).first
          offset += 1
          nowait = (bit_buffer & (1 << 0)) != 0
          table_length = Table.length(data[offset, 5])
          arguments = Table.decode(data[offset, table_length - offset + 1])
          self.new(ticket, destination, source, routing_key, nowait, arguments)
        end

        attr_reader :ticket, :destination, :source, :routing_key, :nowait, :arguments
        def initialize(ticket, destination, source, routing_key, nowait, arguments)
          @ticket = ticket
          @destination = destination
          @source = source
          @routing_key = routing_key
          @nowait = nowait
          @arguments = arguments
        end

        def self.has_content?
          false
        end
      end

      class UnbindOk < Protocol::Method
        @name = "exchange.unbind-ok"
        @method_id = 51
        @index = 0x00280033 # 40, 51, 2621491

        def self.has_content?
          false
        end

        # @return
        # []
        def self.encode(channel)
          pieces = []
          pieces << [40, 51].pack(PACK_CACHE[:n2])
          buffer = pieces.join(EMPTY_STRING)
          MethodFrame.new(buffer, channel)
        end
      end
    end

    class Queue < Protocol::Class
      @name = "queue"
      @method_id = 50

      class Declare < Protocol::Method
        @name = "queue.declare"
        @method_id = 10
        @index = 0x0032000A # 50, 10, 3276810

        # @return
        def self.decode(data)
          offset = 0
          ticket = data[offset, 3].unpack(PACK_CACHE[:n]).first
          offset += 2
          length = data[offset, 2].unpack(PACK_CACHE[:c])[0]
          offset += 1
          queue = data[offset, length]
          offset += length
          bit_buffer = data[offset, 2].unpack(PACK_CACHE[:c]).first
          offset += 1
          passive = (bit_buffer & (1 << 0)) != 0
          table_length = Table.length(data[offset, 5])
          arguments = Table.decode(data[offset, table_length - offset + 1])
          self.new(ticket, queue, passive, durable, exclusive, auto_delete, nowait, arguments)
        end

        attr_reader :ticket, :queue, :passive, :durable, :exclusive, :auto_delete, :nowait, :arguments
        def initialize(ticket, queue, passive, durable, exclusive, auto_delete, nowait, arguments)
          @ticket = ticket
          @queue = queue
          @passive = passive
          @durable = durable
          @exclusive = exclusive
          @auto_delete = auto_delete
          @nowait = nowait
          @arguments = arguments
        end

        def self.has_content?
          false
        end
      end

      class DeclareOk < Protocol::Method
        @name = "queue.declare-ok"
        @method_id = 11
        @index = 0x0032000B # 50, 11, 3276811

        def self.has_content?
          false
        end

        # @return
        # ["queue = nil", "message_count = nil", "consumer_count = nil"]
        def self.encode(channel, queue, message_count, consumer_count)
          pieces = []
          pieces << [50, 11].pack(PACK_CACHE[:n2])
          pieces << queue.bytesize.chr
          pieces << queue
          pieces << [message_count].pack(PACK_CACHE[:N])
          pieces << [consumer_count].pack(PACK_CACHE[:N])
          buffer = pieces.join(EMPTY_STRING)
          MethodFrame.new(buffer, channel)
        end
      end

      class Bind < Protocol::Method
        @name = "queue.bind"
        @method_id = 20
        @index = 0x00320014 # 50, 20, 3276820

        # @return
        def self.decode(data)
          offset = 0
          ticket = data[offset, 3].unpack(PACK_CACHE[:n]).first
          offset += 2
          length = data[offset, 2].unpack(PACK_CACHE[:c])[0]
          offset += 1
          queue = data[offset, length]
          offset += length
          length = data[offset, 2].unpack(PACK_CACHE[:c])[0]
          offset += 1
          exchange = data[offset, length]
          offset += length
          length = data[offset, 2].unpack(PACK_CACHE[:c])[0]
          offset += 1
          routing_key = data[offset, length]
          offset += length
          bit_buffer = data[offset, 2].unpack(PACK_CACHE[:c]).first
          offset += 1
          nowait = (bit_buffer & (1 << 0)) != 0
          table_length = Table.length(data[offset, 5])
          arguments = Table.decode(data[offset, table_length - offset + 1])
          self.new(ticket, queue, exchange, routing_key, nowait, arguments)
        end

        attr_reader :ticket, :queue, :exchange, :routing_key, :nowait, :arguments
        def initialize(ticket, queue, exchange, routing_key, nowait, arguments)
          @ticket = ticket
          @queue = queue
          @exchange = exchange
          @routing_key = routing_key
          @nowait = nowait
          @arguments = arguments
        end

        def self.has_content?
          false
        end
      end

      class BindOk < Protocol::Method
        @name = "queue.bind-ok"
        @method_id = 21
        @index = 0x00320015 # 50, 21, 3276821

        def self.has_content?
          false
        end

        # @return
        # []
        def self.encode(channel)
          pieces = []
          pieces << [50, 21].pack(PACK_CACHE[:n2])
          buffer = pieces.join(EMPTY_STRING)
          MethodFrame.new(buffer, channel)
        end
      end

      class Purge < Protocol::Method
        @name = "queue.purge"
        @method_id = 30
        @index = 0x0032001E # 50, 30, 3276830

        # @return
        def self.decode(data)
          offset = 0
          ticket = data[offset, 3].unpack(PACK_CACHE[:n]).first
          offset += 2
          length = data[offset, 2].unpack(PACK_CACHE[:c])[0]
          offset += 1
          queue = data[offset, length]
          offset += length
          bit_buffer = data[offset, 2].unpack(PACK_CACHE[:c]).first
          offset += 1
          nowait = (bit_buffer & (1 << 0)) != 0
          self.new(ticket, queue, nowait)
        end

        attr_reader :ticket, :queue, :nowait
        def initialize(ticket, queue, nowait)
          @ticket = ticket
          @queue = queue
          @nowait = nowait
        end

        def self.has_content?
          false
        end
      end

      class PurgeOk < Protocol::Method
        @name = "queue.purge-ok"
        @method_id = 31
        @index = 0x0032001F # 50, 31, 3276831

        def self.has_content?
          false
        end

        # @return
        # ["message_count = nil"]
        def self.encode(channel, message_count)
          pieces = []
          pieces << [50, 31].pack(PACK_CACHE[:n2])
          pieces << [message_count].pack(PACK_CACHE[:N])
          buffer = pieces.join(EMPTY_STRING)
          MethodFrame.new(buffer, channel)
        end
      end

      class Delete < Protocol::Method
        @name = "queue.delete"
        @method_id = 40
        @index = 0x00320028 # 50, 40, 3276840

        # @return
        def self.decode(data)
          offset = 0
          ticket = data[offset, 3].unpack(PACK_CACHE[:n]).first
          offset += 2
          length = data[offset, 2].unpack(PACK_CACHE[:c])[0]
          offset += 1
          queue = data[offset, length]
          offset += length
          bit_buffer = data[offset, 2].unpack(PACK_CACHE[:c]).first
          offset += 1
          if_unused = (bit_buffer & (1 << 0)) != 0
          self.new(ticket, queue, if_unused, if_empty, nowait)
        end

        attr_reader :ticket, :queue, :if_unused, :if_empty, :nowait
        def initialize(ticket, queue, if_unused, if_empty, nowait)
          @ticket = ticket
          @queue = queue
          @if_unused = if_unused
          @if_empty = if_empty
          @nowait = nowait
        end

        def self.has_content?
          false
        end
      end

      class DeleteOk < Protocol::Method
        @name = "queue.delete-ok"
        @method_id = 41
        @index = 0x00320029 # 50, 41, 3276841

        def self.has_content?
          false
        end

        # @return
        # ["message_count = nil"]
        def self.encode(channel, message_count)
          pieces = []
          pieces << [50, 41].pack(PACK_CACHE[:n2])
          pieces << [message_count].pack(PACK_CACHE[:N])
          buffer = pieces.join(EMPTY_STRING)
          MethodFrame.new(buffer, channel)
        end
      end

      class Unbind < Protocol::Method
        @name = "queue.unbind"
        @method_id = 50
        @index = 0x00320032 # 50, 50, 3276850

        # @return
        def self.decode(data)
          offset = 0
          ticket = data[offset, 3].unpack(PACK_CACHE[:n]).first
          offset += 2
          length = data[offset, 2].unpack(PACK_CACHE[:c])[0]
          offset += 1
          queue = data[offset, length]
          offset += length
          length = data[offset, 2].unpack(PACK_CACHE[:c])[0]
          offset += 1
          exchange = data[offset, length]
          offset += length
          length = data[offset, 2].unpack(PACK_CACHE[:c])[0]
          offset += 1
          routing_key = data[offset, length]
          offset += length
          table_length = Table.length(data[offset, 5])
          arguments = Table.decode(data[offset, table_length - offset + 1])
          self.new(ticket, queue, exchange, routing_key, arguments)
        end

        attr_reader :ticket, :queue, :exchange, :routing_key, :arguments
        def initialize(ticket, queue, exchange, routing_key, arguments)
          @ticket = ticket
          @queue = queue
          @exchange = exchange
          @routing_key = routing_key
          @arguments = arguments
        end

        def self.has_content?
          false
        end
      end

      class UnbindOk < Protocol::Method
        @name = "queue.unbind-ok"
        @method_id = 51
        @index = 0x00320033 # 50, 51, 3276851

        def self.has_content?
          false
        end

        # @return
        # []
        def self.encode(channel)
          pieces = []
          pieces << [50, 51].pack(PACK_CACHE[:n2])
          buffer = pieces.join(EMPTY_STRING)
          MethodFrame.new(buffer, channel)
        end
      end
    end

    class Basic < Protocol::Class
      @name = "basic"
      @method_id = 60

      PROPERTIES = [
        :content_type, # shortstr
        :content_encoding, # shortstr
        :headers, # table
        :delivery_mode, # octet
        :priority, # octet
        :correlation_id, # shortstr
        :reply_to, # shortstr
        :expiration, # shortstr
        :message_id, # shortstr
        :timestamp, # timestamp
        :type, # shortstr
        :user_id, # shortstr
        :app_id, # shortstr
        :cluster_id, # shortstr
      ]

      # 1 << 15
      def self.encode_content_type(value)
        pieces = []
        pieces << value.bytesize.chr
        pieces << value
        [0, 0x8000, pieces.join(EMPTY_STRING)]
      end

      # 1 << 14
      def self.encode_content_encoding(value)
        pieces = []
        pieces << value.bytesize.chr
        pieces << value
        [1, 0x4000, pieces.join(EMPTY_STRING)]
      end

      # 1 << 13
      def self.encode_headers(value)
        pieces = []
        pieces << AMQ::Protocol::Table.encode(value)
        [2, 0x2000, pieces.join(EMPTY_STRING)]
      end

      # 1 << 12
      def self.encode_delivery_mode(value)
        pieces = []
        pieces << [value].pack(PACK_CACHE[:c])
        [3, 0x1000, pieces.join(EMPTY_STRING)]
      end

      # 1 << 11
      def self.encode_priority(value)
        pieces = []
        pieces << [value].pack(PACK_CACHE[:c])
        [4, 0x0800, pieces.join(EMPTY_STRING)]
      end

      # 1 << 10
      def self.encode_correlation_id(value)
        pieces = []
        pieces << value.bytesize.chr
        pieces << value
        [5, 0x0400, pieces.join(EMPTY_STRING)]
      end

      # 1 << 9
      def self.encode_reply_to(value)
        pieces = []
        pieces << value.bytesize.chr
        pieces << value
        [6, 0x0200, pieces.join(EMPTY_STRING)]
      end

      # 1 << 8
      def self.encode_expiration(value)
        pieces = []
        pieces << value.bytesize.chr
        pieces << value
        [7, 0x0100, pieces.join(EMPTY_STRING)]
      end

      # 1 << 7
      def self.encode_message_id(value)
        pieces = []
        pieces << value.bytesize.chr
        pieces << value
        [8, 0x0080, pieces.join(EMPTY_STRING)]
      end

      # 1 << 6
      def self.encode_timestamp(value)
        pieces = []
        pieces << AMQ::Hacks.pack_64_big_endian(value)
        [9, 0x0040, pieces.join(EMPTY_STRING)]
      end

      # 1 << 5
      def self.encode_type(value)
        pieces = []
        pieces << value.bytesize.chr
        pieces << value
        [10, 0x0020, pieces.join(EMPTY_STRING)]
      end

      # 1 << 4
      def self.encode_user_id(value)
        pieces = []
        pieces << value.bytesize.chr
        pieces << value
        [11, 0x0010, pieces.join(EMPTY_STRING)]
      end

      # 1 << 3
      def self.encode_app_id(value)
        pieces = []
        pieces << value.bytesize.chr
        pieces << value
        [12, 0x0008, pieces.join(EMPTY_STRING)]
      end

      # 1 << 2
      def self.encode_cluster_id(value)
        pieces = []
        pieces << value.bytesize.chr
        pieces << value
        [13, 0x0004, pieces.join(EMPTY_STRING)]
      end

      def self.encode_properties(body_size, properties)
        pieces, flags = [], 0

        properties.each do |key, value|
          i, f, result = self.send(:"encode_#{key}", value)
          flags |= f
          pieces[i] = result
        end

        # result = [60, 0, body_size, flags].pack(PACK_CACHE[:n2Qn])
        result = [60, 0].pack(PACK_CACHE[:n2])
        result += AMQ::Hacks.pack_64_big_endian(body_size)
        result += [flags].pack(PACK_CACHE[:n])
        result + pieces.join(EMPTY_STRING)
      end

      # DECODE PROPERTIES
      # 1 << 15
      def self.decode_content_type(data)
        pieces = []
        pieces << value.bytesize.chr
        pieces << value
        [0, 0x8000, pieces.join("")]
      end

      # 1 << 14
      def self.decode_content_encoding(data)
        pieces = []
        pieces << value.bytesize.chr
        pieces << value
        [1, 0x4000, pieces.join("")]
      end

      # 1 << 13
      def self.decode_headers(data)
        pieces = []
        pieces << AMQ::Protocol::Table.encode(value)
        [2, 0x2000, pieces.join("")]
      end

      # 1 << 12
      def self.decode_delivery_mode(data)
        pieces = []
        pieces << [value].pack(PACK_CACHE[:c])
        [3, 0x1000, pieces.join("")]
      end

      # 1 << 11
      def self.decode_priority(data)
        pieces = []
        pieces << [value].pack(PACK_CACHE[:c])
        [4, 0x0800, pieces.join("")]
      end

      # 1 << 10
      def self.decode_correlation_id(data)
        pieces = []
        pieces << value.bytesize.chr
        pieces << value
        [5, 0x0400, pieces.join("")]
      end

      # 1 << 9
      def self.decode_reply_to(data)
        pieces = []
        pieces << value.bytesize.chr
        pieces << value
        [6, 0x0200, pieces.join("")]
      end

      # 1 << 8
      def self.decode_expiration(data)
        pieces = []
        pieces << value.bytesize.chr
        pieces << value
        [7, 0x0100, pieces.join("")]
      end

      # 1 << 7
      def self.decode_message_id(data)
        pieces = []
        pieces << value.bytesize.chr
        pieces << value
        [8, 0x0080, pieces.join("")]
      end

      # 1 << 6
      def self.decode_timestamp(data)
        pieces = []
        pieces << AMQ::Hacks.pack_64_big_endian(value)
        [9, 0x0040, pieces.join("")]
      end

      # 1 << 5
      def self.decode_type(data)
        pieces = []
        pieces << value.bytesize.chr
        pieces << value
        [10, 0x0020, pieces.join("")]
      end

      # 1 << 4
      def self.decode_user_id(data)
        pieces = []
        pieces << value.bytesize.chr
        pieces << value
        [11, 0x0010, pieces.join("")]
      end

      # 1 << 3
      def self.decode_app_id(data)
        pieces = []
        pieces << value.bytesize.chr
        pieces << value
        [12, 0x0008, pieces.join("")]
      end

      # 1 << 2
      def self.decode_cluster_id(data)
        pieces = []
        pieces << value.bytesize.chr
        pieces << value
        [13, 0x0004, pieces.join("")]
      end

      # THIS DECODES ONLY FLAGS
      DECODE_PROPERTIES = {
        0x8000 => :content_type,
        0x4000 => :content_encoding,
        0x2000 => :headers,
        0x1000 => :delivery_mode,
        0x0800 => :priority,
        0x0400 => :correlation_id,
        0x0200 => :reply_to,
        0x0100 => :expiration,
        0x0080 => :message_id,
        0x0040 => :timestamp,
        0x0020 => :type,
        0x0010 => :user_id,
        0x0008 => :app_id,
        0x0004 => :cluster_id,
      }

      DECODE_PROPERTIES_TYPE = {
        0x8000 => :shortstr,
        0x4000 => :shortstr,
        0x2000 => :table,
        0x1000 => :octet,
        0x0800 => :octet,
        0x0400 => :shortstr,
        0x0200 => :shortstr,
        0x0100 => :shortstr,
        0x0080 => :shortstr,
        0x0040 => :timestamp,
        0x0020 => :shortstr,
        0x0010 => :shortstr,
        0x0008 => :shortstr,
        0x0004 => :shortstr,
      }

      # Hash doesn"t give any guarantees on keys order, we will do it in a
      # straightforward way
      DECODE_PROPERTIES_KEYS = [
        0x8000,
        0x4000,
        0x2000,
        0x1000,
        0x0800,
        0x0400,
        0x0200,
        0x0100,
        0x0080,
        0x0040,
        0x0020,
        0x0010,
        0x0008,
        0x0004,
      ]

      def self.decode_content_type(data)
        data
      end

      def self.decode_content_encoding(data)
        data
      end

      def self.decode_headers(data)
        Table.decode(data)
      end

      def self.decode_delivery_mode(data)
        data.unpack(PACK_CACHE[:c]).first
      end

      def self.decode_priority(data)
        data.unpack(PACK_CACHE[:c]).first
      end

      def self.decode_correlation_id(data)
        data
      end

      def self.decode_reply_to(data)
        data
      end

      def self.decode_expiration(data)
        data
      end

      def self.decode_message_id(data)
        data
      end

      def self.decode_timestamp(data)
        Time.at(data.unpack(PACK_CACHE[:N2]).last)
      end

      def self.decode_type(data)
        data
      end

      def self.decode_user_id(data)
        data
      end

      def self.decode_app_id(data)
        data
      end

      def self.decode_cluster_id(data)
        data
      end

      def self.decode_properties(data)
        offset, data_length, properties = 0, data.bytesize, {}

        compressed_index = data[offset, 2].unpack(PACK_CACHE[:n])[0]
        offset += 2
        while data_length > offset
          DECODE_PROPERTIES_KEYS.each do |key|
            next unless compressed_index >= key
            compressed_index -= key
            name = DECODE_PROPERTIES[key] || raise(RuntimeError.new("No property found for index #{index.inspect}!"))
            case DECODE_PROPERTIES_TYPE[key]
            when :shortstr
              size = data[offset, 1].unpack(PACK_CACHE[:c])[0]
              offset += 1
            when :octet
              size = 1
            when :timestamp
              size = 8
            when :table
              size = data[offset, 4].unpack(PACK_CACHE[:N])[0]
              offset += 4
            end
            result = self.send(:"decode_#{name}", data[offset, size])
            properties[name] = result
            offset += size
          end
        end

        properties
      end

      class Qos < Protocol::Method
        @name = "basic.qos"
        @method_id = 10
        @index = 0x003C000A # 60, 10, 3932170

        # @return
        def self.decode(data)
          offset = 0
          prefetch_size = data[offset, 5].unpack(PACK_CACHE[:N]).first
          offset += 4
          prefetch_count = data[offset, 3].unpack(PACK_CACHE[:n]).first
          offset += 2
          bit_buffer = data[offset, 2].unpack(PACK_CACHE[:c]).first
          offset += 1
          global = (bit_buffer & (1 << 0)) != 0
          self.new(prefetch_size, prefetch_count, global)
        end

        attr_reader :prefetch_size, :prefetch_count, :global
        def initialize(prefetch_size, prefetch_count, global)
          @prefetch_size = prefetch_size
          @prefetch_count = prefetch_count
          @global = global
        end

        def self.has_content?
          false
        end
      end

      class QosOk < Protocol::Method
        @name = "basic.qos-ok"
        @method_id = 11
        @index = 0x003C000B # 60, 11, 3932171

        def self.has_content?
          false
        end

        # @return
        # []
        def self.encode(channel)
          pieces = []
          pieces << [60, 11].pack(PACK_CACHE[:n2])
          buffer = pieces.join(EMPTY_STRING)
          MethodFrame.new(buffer, channel)
        end
      end

      class Consume < Protocol::Method
        @name = "basic.consume"
        @method_id = 20
        @index = 0x003C0014 # 60, 20, 3932180

        # @return
        def self.decode(data)
          offset = 0
          ticket = data[offset, 3].unpack(PACK_CACHE[:n]).first
          offset += 2
          length = data[offset, 2].unpack(PACK_CACHE[:c])[0]
          offset += 1
          queue = data[offset, length]
          offset += length
          length = data[offset, 2].unpack(PACK_CACHE[:c])[0]
          offset += 1
          consumer_tag = data[offset, length]
          offset += length
          bit_buffer = data[offset, 2].unpack(PACK_CACHE[:c]).first
          offset += 1
          no_local = (bit_buffer & (1 << 0)) != 0
          table_length = Table.length(data[offset, 5])
          arguments = Table.decode(data[offset, table_length - offset + 1])
          self.new(ticket, queue, consumer_tag, no_local, no_ack, exclusive, nowait, arguments)
        end

        attr_reader :ticket, :queue, :consumer_tag, :no_local, :no_ack, :exclusive, :nowait, :arguments
        def initialize(ticket, queue, consumer_tag, no_local, no_ack, exclusive, nowait, arguments)
          @ticket = ticket
          @queue = queue
          @consumer_tag = consumer_tag
          @no_local = no_local
          @no_ack = no_ack
          @exclusive = exclusive
          @nowait = nowait
          @arguments = arguments
        end

        def self.has_content?
          false
        end
      end

      class ConsumeOk < Protocol::Method
        @name = "basic.consume-ok"
        @method_id = 21
        @index = 0x003C0015 # 60, 21, 3932181

        def self.has_content?
          false
        end

        # @return
        # ["consumer_tag = nil"]
        def self.encode(channel, consumer_tag)
          pieces = []
          pieces << [60, 21].pack(PACK_CACHE[:n2])
          pieces << consumer_tag.bytesize.chr
          pieces << consumer_tag
          buffer = pieces.join(EMPTY_STRING)
          MethodFrame.new(buffer, channel)
        end
      end

      class Cancel < Protocol::Method
        @name = "basic.cancel"
        @method_id = 30
        @index = 0x003C001E # 60, 30, 3932190

        # @return
        def self.decode(data)
          offset = 0
          length = data[offset, 2].unpack(PACK_CACHE[:c])[0]
          offset += 1
          consumer_tag = data[offset, length]
          offset += length
          bit_buffer = data[offset, 2].unpack(PACK_CACHE[:c]).first
          offset += 1
          nowait = (bit_buffer & (1 << 0)) != 0
          self.new(consumer_tag, nowait)
        end

        attr_reader :consumer_tag, :nowait
        def initialize(consumer_tag, nowait)
          @consumer_tag = consumer_tag
          @nowait = nowait
        end

        def self.has_content?
          false
        end
      end

      class CancelOk < Protocol::Method
        @name = "basic.cancel-ok"
        @method_id = 31
        @index = 0x003C001F # 60, 31, 3932191

        def self.has_content?
          false
        end

        # @return
        # ["consumer_tag = nil"]
        def self.encode(channel, consumer_tag)
          pieces = []
          pieces << [60, 31].pack(PACK_CACHE[:n2])
          pieces << consumer_tag.bytesize.chr
          pieces << consumer_tag
          buffer = pieces.join(EMPTY_STRING)
          MethodFrame.new(buffer, channel)
        end
      end

      class Publish < Protocol::Method
        @name = "basic.publish"
        @method_id = 40
        @index = 0x003C0028 # 60, 40, 3932200

        # @return
        def self.decode(data)
          offset = 0
          ticket = data[offset, 3].unpack(PACK_CACHE[:n]).first
          offset += 2
          length = data[offset, 2].unpack(PACK_CACHE[:c])[0]
          offset += 1
          exchange = data[offset, length]
          offset += length
          length = data[offset, 2].unpack(PACK_CACHE[:c])[0]
          offset += 1
          routing_key = data[offset, length]
          offset += length
          bit_buffer = data[offset, 2].unpack(PACK_CACHE[:c]).first
          offset += 1
          mandatory = (bit_buffer & (1 << 0)) != 0
          self.new(ticket, exchange, routing_key, mandatory, immediate)
        end

        attr_reader :ticket, :exchange, :routing_key, :mandatory, :immediate
        def initialize(ticket, exchange, routing_key, mandatory, immediate)
          @ticket = ticket
          @exchange = exchange
          @routing_key = routing_key
          @mandatory = mandatory
          @immediate = immediate
        end

        def self.has_content?
          true
        end
      end

      class Return < Protocol::Method
        @name = "basic.return"
        @method_id = 50
        @index = 0x003C0032 # 60, 50, 3932210

        def self.has_content?
          true
        end

        # @return
        # ["reply_code = nil", "reply_text = EMPTY_STRING", "exchange = nil", "routing_key = nil", "user_headers = nil", "payload = """, "frame_size = nil"]
        def self.encode(channel, payload, user_headers, reply_code, reply_text, exchange, routing_key, frame_size)
          pieces = []
          pieces << [60, 50].pack(PACK_CACHE[:n2])
          pieces << [reply_code].pack(PACK_CACHE[:n])
          pieces << reply_text.bytesize.chr
          pieces << reply_text
          pieces << exchange.bytesize.chr
          pieces << exchange
          pieces << routing_key.bytesize.chr
          pieces << routing_key
          buffer = pieces.join(EMPTY_STRING)
          frames = [MethodFrame.new(buffer, channel)]
          properties, headers = self.split_headers(user_headers)
          # TODO: what shall I do with the headers?
          if properties.nil? or properties.empty?
            raise RuntimeError.new("Properties can not be empty!") # TODO: or can they?
          end
          properties_payload = Basic.encode_properties(payload.bytesize, properties)
          frames << HeadersFrame.new(properties_payload, channel)
          frames + self.encode_body(payload, channel, frame_size)
        end
      end

      class Deliver < Protocol::Method
        @name = "basic.deliver"
        @method_id = 60
        @index = 0x003C003C # 60, 60, 3932220

        def self.has_content?
          true
        end

        # @return
        # ["consumer_tag = nil", "delivery_tag = nil", "redelivered = false", "exchange = nil", "routing_key = nil", "user_headers = nil", "payload = """, "frame_size = nil"]
        def self.encode(channel, payload, user_headers, consumer_tag, delivery_tag, redelivered, exchange, routing_key, frame_size)
          pieces = []
          pieces << [60, 60].pack(PACK_CACHE[:n2])
          pieces << consumer_tag.bytesize.chr
          pieces << consumer_tag
          pieces << AMQ::Hacks.pack_64_big_endian(delivery_tag)
          bit_buffer = 0
          bit_buffer = bit_buffer | (1 << 0) if redelivered
          pieces << [bit_buffer].pack(PACK_CACHE[:c])
          pieces << exchange.bytesize.chr
          pieces << exchange
          pieces << routing_key.bytesize.chr
          pieces << routing_key
          buffer = pieces.join(EMPTY_STRING)
          frames = [MethodFrame.new(buffer, channel)]
          properties, headers = self.split_headers(user_headers)
          # TODO: what shall I do with the headers?
          if properties.nil? or properties.empty?
            raise RuntimeError.new("Properties can not be empty!") # TODO: or can they?
          end
          properties_payload = Basic.encode_properties(payload.bytesize, properties)
          frames << HeadersFrame.new(properties_payload, channel)
          frames + self.encode_body(payload, channel, frame_size)
        end
      end

      class Get < Protocol::Method
        @name = "basic.get"
        @method_id = 70
        @index = 0x003C0046 # 60, 70, 3932230

        # @return
        def self.decode(data)
          offset = 0
          ticket = data[offset, 3].unpack(PACK_CACHE[:n]).first
          offset += 2
          length = data[offset, 2].unpack(PACK_CACHE[:c])[0]
          offset += 1
          queue = data[offset, length]
          offset += length
          bit_buffer = data[offset, 2].unpack(PACK_CACHE[:c]).first
          offset += 1
          no_ack = (bit_buffer & (1 << 0)) != 0
          self.new(ticket, queue, no_ack)
        end

        attr_reader :ticket, :queue, :no_ack
        def initialize(ticket, queue, no_ack)
          @ticket = ticket
          @queue = queue
          @no_ack = no_ack
        end

        def self.has_content?
          false
        end
      end

      class GetOk < Protocol::Method
        @name = "basic.get-ok"
        @method_id = 71
        @index = 0x003C0047 # 60, 71, 3932231

        def self.has_content?
          true
        end

        # @return
        # ["delivery_tag = nil", "redelivered = false", "exchange = nil", "routing_key = nil", "message_count = nil", "user_headers = nil", "payload = """, "frame_size = nil"]
        def self.encode(channel, payload, user_headers, delivery_tag, redelivered, exchange, routing_key, message_count, frame_size)
          pieces = []
          pieces << [60, 71].pack(PACK_CACHE[:n2])
          pieces << AMQ::Hacks.pack_64_big_endian(delivery_tag)
          bit_buffer = 0
          bit_buffer = bit_buffer | (1 << 0) if redelivered
          pieces << [bit_buffer].pack(PACK_CACHE[:c])
          pieces << exchange.bytesize.chr
          pieces << exchange
          pieces << routing_key.bytesize.chr
          pieces << routing_key
          pieces << [message_count].pack(PACK_CACHE[:N])
          buffer = pieces.join(EMPTY_STRING)
          frames = [MethodFrame.new(buffer, channel)]
          properties, headers = self.split_headers(user_headers)
          # TODO: what shall I do with the headers?
          if properties.nil? or properties.empty?
            raise RuntimeError.new("Properties can not be empty!") # TODO: or can they?
          end
          properties_payload = Basic.encode_properties(payload.bytesize, properties)
          frames << HeadersFrame.new(properties_payload, channel)
          frames + self.encode_body(payload, channel, frame_size)
        end
      end

      class GetEmpty < Protocol::Method
        @name = "basic.get-empty"
        @method_id = 72
        @index = 0x003C0048 # 60, 72, 3932232

        def self.has_content?
          false
        end

        # @return
        # ["cluster_id = EMPTY_STRING"]
        def self.encode(channel, cluster_id)
          pieces = []
          pieces << [60, 72].pack(PACK_CACHE[:n2])
          pieces << cluster_id.bytesize.chr
          pieces << cluster_id
          buffer = pieces.join(EMPTY_STRING)
          MethodFrame.new(buffer, channel)
        end
      end

      class Ack < Protocol::Method
        @name = "basic.ack"
        @method_id = 80
        @index = 0x003C0050 # 60, 80, 3932240

        # @return
        def self.decode(data)
          offset = 0
          delivery_tag = AMQ::Hacks.unpack_64_big_endian(data[offset, 8]).first
          offset += 8
          bit_buffer = data[offset, 2].unpack(PACK_CACHE[:c]).first
          offset += 1
          multiple = (bit_buffer & (1 << 0)) != 0
          self.new(delivery_tag, multiple)
        end

        attr_reader :delivery_tag, :multiple
        def initialize(delivery_tag, multiple)
          @delivery_tag = delivery_tag
          @multiple = multiple
        end

        def self.has_content?
          false
        end
      end

      class Reject < Protocol::Method
        @name = "basic.reject"
        @method_id = 90
        @index = 0x003C005A # 60, 90, 3932250

        # @return
        def self.decode(data)
          offset = 0
          delivery_tag = AMQ::Hacks.unpack_64_big_endian(data[offset, 8]).first
          offset += 8
          bit_buffer = data[offset, 2].unpack(PACK_CACHE[:c]).first
          offset += 1
          requeue = (bit_buffer & (1 << 0)) != 0
          self.new(delivery_tag, requeue)
        end

        attr_reader :delivery_tag, :requeue
        def initialize(delivery_tag, requeue)
          @delivery_tag = delivery_tag
          @requeue = requeue
        end

        def self.has_content?
          false
        end
      end

      class RecoverAsync < Protocol::Method
        @name = "basic.recover-async"
        @method_id = 100
        @index = 0x003C0064 # 60, 100, 3932260

        # @return
        def self.decode(data)
          offset = 0
          bit_buffer = data[offset, 2].unpack(PACK_CACHE[:c]).first
          offset += 1
          requeue = (bit_buffer & (1 << 0)) != 0
          self.new(requeue)
        end

        attr_reader :requeue
        def initialize(requeue)
          @requeue = requeue
        end

        def self.has_content?
          false
        end
      end

      class Recover < Protocol::Method
        @name = "basic.recover"
        @method_id = 110
        @index = 0x003C006E # 60, 110, 3932270

        # @return
        def self.decode(data)
          offset = 0
          bit_buffer = data[offset, 2].unpack(PACK_CACHE[:c]).first
          offset += 1
          requeue = (bit_buffer & (1 << 0)) != 0
          self.new(requeue)
        end

        attr_reader :requeue
        def initialize(requeue)
          @requeue = requeue
        end

        def self.has_content?
          false
        end
      end

      class RecoverOk < Protocol::Method
        @name = "basic.recover-ok"
        @method_id = 111
        @index = 0x003C006F # 60, 111, 3932271

        def self.has_content?
          false
        end

        # @return
        # []
        def self.encode(channel)
          pieces = []
          pieces << [60, 111].pack(PACK_CACHE[:n2])
          buffer = pieces.join(EMPTY_STRING)
          MethodFrame.new(buffer, channel)
        end
      end

      class Nack < Protocol::Method
        @name = "basic.nack"
        @method_id = 120
        @index = 0x003C0078 # 60, 120, 3932280

        # @return
        def self.decode(data)
          offset = 0
          delivery_tag = AMQ::Hacks.unpack_64_big_endian(data[offset, 8]).first
          offset += 8
          bit_buffer = data[offset, 2].unpack(PACK_CACHE[:c]).first
          offset += 1
          multiple = (bit_buffer & (1 << 0)) != 0
          self.new(delivery_tag, multiple, requeue)
        end

        attr_reader :delivery_tag, :multiple, :requeue
        def initialize(delivery_tag, multiple, requeue)
          @delivery_tag = delivery_tag
          @multiple = multiple
          @requeue = requeue
        end

        def self.has_content?
          false
        end

        # @return
        # ["delivery_tag = false", "multiple = false", "requeue = true"]
        def self.encode(channel, delivery_tag, multiple, requeue)
          pieces = []
          pieces << [60, 120].pack(PACK_CACHE[:n2])
          pieces << AMQ::Hacks.pack_64_big_endian(delivery_tag)
          bit_buffer = 0
          bit_buffer = bit_buffer | (1 << 0) if multiple
          bit_buffer = bit_buffer | (1 << 1) if requeue
          pieces << [bit_buffer].pack(PACK_CACHE[:c])
          buffer = pieces.join(EMPTY_STRING)
          MethodFrame.new(buffer, channel)
        end
      end
    end

    class Tx < Protocol::Class
      @name = "tx"
      @method_id = 90

      class Select < Protocol::Method
        @name = "tx.select"
        @method_id = 10
        @index = 0x005A000A # 90, 10, 5898250

        # @return
        def self.decode(data)
          offset = 0
          self.new()
        end

        def initialize()
        end

        def self.has_content?
          false
        end
      end

      class SelectOk < Protocol::Method
        @name = "tx.select-ok"
        @method_id = 11
        @index = 0x005A000B # 90, 11, 5898251

        def self.has_content?
          false
        end

        # @return
        # []
        def self.encode(channel)
          pieces = []
          pieces << [90, 11].pack(PACK_CACHE[:n2])
          buffer = pieces.join(EMPTY_STRING)
          MethodFrame.new(buffer, channel)
        end
      end

      class Commit < Protocol::Method
        @name = "tx.commit"
        @method_id = 20
        @index = 0x005A0014 # 90, 20, 5898260

        # @return
        def self.decode(data)
          offset = 0
          self.new()
        end

        def initialize()
        end

        def self.has_content?
          false
        end
      end

      class CommitOk < Protocol::Method
        @name = "tx.commit-ok"
        @method_id = 21
        @index = 0x005A0015 # 90, 21, 5898261

        def self.has_content?
          false
        end

        # @return
        # []
        def self.encode(channel)
          pieces = []
          pieces << [90, 21].pack(PACK_CACHE[:n2])
          buffer = pieces.join(EMPTY_STRING)
          MethodFrame.new(buffer, channel)
        end
      end

      class Rollback < Protocol::Method
        @name = "tx.rollback"
        @method_id = 30
        @index = 0x005A001E # 90, 30, 5898270

        # @return
        def self.decode(data)
          offset = 0
          self.new()
        end

        def initialize()
        end

        def self.has_content?
          false
        end
      end

      class RollbackOk < Protocol::Method
        @name = "tx.rollback-ok"
        @method_id = 31
        @index = 0x005A001F # 90, 31, 5898271

        def self.has_content?
          false
        end

        # @return
        # []
        def self.encode(channel)
          pieces = []
          pieces << [90, 31].pack(PACK_CACHE[:n2])
          buffer = pieces.join(EMPTY_STRING)
          MethodFrame.new(buffer, channel)
        end
      end
    end

    class Confirm < Protocol::Class
      @name = "confirm"
      @method_id = 85

      class Select < Protocol::Method
        @name = "confirm.select"
        @method_id = 10
        @index = 0x0055000A # 85, 10, 5570570

        # @return
        def self.decode(data)
          offset = 0
          bit_buffer = data[offset, 2].unpack(PACK_CACHE[:c]).first
          offset += 1
          nowait = (bit_buffer & (1 << 0)) != 0
          self.new(nowait)
        end

        attr_reader :nowait
        def initialize(nowait)
          @nowait = nowait
        end

        def self.has_content?
          false
        end

        # @return
        # ["nowait = false"]
        def self.encode(channel, nowait)
          pieces = []
          pieces << [85, 10].pack(PACK_CACHE[:n2])
          bit_buffer = 0
          bit_buffer = bit_buffer | (1 << 0) if nowait
          pieces << [bit_buffer].pack(PACK_CACHE[:c])
          buffer = pieces.join(EMPTY_STRING)
          MethodFrame.new(buffer, channel)
        end
      end

      class SelectOk < Protocol::Method
        @name = "confirm.select-ok"
        @method_id = 11
        @index = 0x0055000B # 85, 11, 5570571

        # @return
        def self.decode(data)
          offset = 0
          self.new()
        end

        def initialize()
        end

        def self.has_content?
          false
        end

        # @return
        # []
        def self.encode(channel)
          pieces = []
          pieces << [85, 11].pack(PACK_CACHE[:n2])
          buffer = pieces.join(EMPTY_STRING)
          MethodFrame.new(buffer, channel)
        end
      end
    end

    METHODS = begin
      Method.methods.inject(Hash.new) do |hash, klass|
        hash.merge!(klass.index => klass)
      end
    end
  end
end
